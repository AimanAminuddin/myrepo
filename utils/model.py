from docplex.mp.model import Model
import pandas as pd

import logging

# Setup at the top of your script or notebook
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')


class TutorAssignmentModel:
    '''
    Wrapper class to optimize the assignment of 
    students to tutors based on both student preference(s)/
    tutor preference(s)
    '''
    def __init__(self,new_students,tutor_info,existing_students,beta = 0.9,scenario=1):
        '''
        Assign variable(s) to be class properties
        '''
        self.new_students = new_students
        self.tutor_info = tutor_info
        self.existing_students = existing_students
        self.beta = beta
        # Control which objective function to used for different
        # task
        self.scenario = scenario

        self.model = Model(name="tutor_student_assignment")
        # Assignment_variable_mappings
        self.assign_vars = {}
        self.tutor_used = {}

    # Create assigment variable(s)
    def create_variables(self):
        '''
        Create mappings for assignment of students and
        total of tutors used in each centre
        '''
        # Decision variable(s) that keep track of student-tutor assignment(s)
        self.assign_vars = {
            (new_student['studentId'], tutor['tutorId']): self.model.binary_var(name=f"x_{new_student['studentId']}_{tutor['tutorId']}")
            for _, new_student in self.new_students.iterrows()
            for _, tutor in self.tutor_info.iterrows()
            }

        # Decision variable that keep tracks if tutor is been utilised by
        # the tuition centre(s)
        self.tutor_used = {
            t['tutorId']: self.model.binary_var(name=f"tutor_used_{t['tutorId']}")
            for _, t in self.tutor_info.iterrows()
            }

    # Add constraints
    def add_constraints(self):
        '''
        Method that contains all the constraint(s) that 
        the solution(s) generated by the model require to adhere to
        '''
        # Each student assigned to exactly 1
        # tutor
        for _,new_student in self.new_students.iterrows():
            self.model.add_constraint(
                sum(self.assign_vars[new_student['studentId'], tutor['tutorId']]
                    for _, tutor in self.tutor_info.iterrows()) == 1,
                ctname=f"one_tutor_per_student_{new_student['studentId']}"
            )

        # Solution cannot exceed Tutor Capacity i.e. (new + existing students) <= MaxOverallCapacity
        ## Calculate total number of existing students by tutor
        existing_student_count = self.existing_students.groupby(['tutorId']).size().to_dict()

        for _,tutor in self.tutor_info.iterrows():
            # Iterate through each tutor and
            # ensure that each tutor max capacity
            # not violated
            tutor_id = tutor['tutorId']
            max_capacity = tutor['maxOverallCapacity']
            current_student_count = existing_student_count.get(tutor_id,0)

            self.model.add_constraint(
                sum(self.assign_vars[new_student['studentId'],tutor_id] for _,new_student in \
                    self.new_students.iterrows()) + current_student_count <= max_capacity,
                ctname=f"capacity_tutor_{tutor_id}"
            )

        # Skill compatability: Students with 'Extensive' tutoringNeed must
        # match with tutor(s) with 'Extensive' tutoringSkills
        for _,new_student in self.new_students.iterrows():
            for _,tutor in self.tutor_info.iterrows():
                if new_student['tutoringNeed'] == 'Extensive' and tutor['tutoringSkills'] != 'Extensive':
                    # force assignment to 0
                    # i.e. student now allowed to be taught
                    # specific tutor
                    self.model.add_constraint(
                        self.assign_vars[(new_student['studentId'],tutor['tutorId'])] == 0,
                        ctname=f"skill_block_{new_student['studentId']}_{tutor['tutorId']}"
                        )
        
        # tutor_used decision variable can only be set to 1
        # iff there exists tutor-student assignment for tutor
        for tutor_id in self.tutor_used:
            # If tutor already has existing students,tutor_used = 1
            if existing_student_count.get(tutor_id,0) > 0:
                # Set tutor_used to 1
                self.model.add_constraint(
                    self.tutor_used[tutor_id] == 1,
                    ctname=f"existing_tutor_used_{tutor_id}"
                    )
            else:
                # tutor_used = 1 if any new sutdent assigned
                for _,new_student in self.new_students.iterrows():
                    self.model.add_constraint(
                        self.assign_vars[(new_student['studentId'], tutor_id)] <= self.tutor_used[tutor_id],
                        ctname=f"link_assign_tutor_{new_student['studentId']}_{tutor_id}"
                        )

        return
    
    # Set the objective function
    def set_objective_function(self,scenario):
        '''
        Based on the above constraint(s),generate the objective
        function for Scenario 1 and 2:
        1.Scenario 1:
            Minimize total number of assigned while maximizing tutor preference
            on tuition centre
        2.Scenario 2:
            Balance tutor workload while maximizing preference on tuition centre
        '''
        # Build preference matrix
        preference_matrix = {}
        for _,new_student in self.new_students.iterrows():
            for _,tutor in self.tutor_info.iterrows():
                if new_student['tuitionCentre'] == tutor['preferredCentre1']:
                    preference_matrix[new_student['studentId'],tutor['tutorId']] = 1
                elif new_student['tuitionCentre'] == tutor['preferredCentre2']:
                    preference_matrix[new_student['studentId'],tutor['tutorId']] = 0.5
                else:
                    preference_matrix[new_student['studentId'],tutor['tutorId']] = 0
        
        # Generate term that model tutor's preferences being met
        preference_term = sum(
            self.assign_vars[new_student['studentId'], tutor['tutorId']] * self.beta * 
            preference_matrix[new_student['studentId'], tutor['tutorId']]
            for _,new_student in self.new_students.iterrows()
            for _,tutor in self.tutor_info.iterrows()
            )
        
        # Generate term that model the total tutors used
        tutor_used_term = sum(self.tutor_used[tutor_id] * (1 - self.beta) for tutor_id in self.tutor_used)

        # Compute free capacity for Scenario 2
        existing_counts = self.existing_students.groupby('tutorId').size().to_dict()
        free_capacity = {}
        for _, tutor in self.tutor_info.iterrows():
            tutor_id = tutor['tutorId']
            tutor_max_capacity = tutor['maxOverallCapacity']
            existing_student_count = existing_counts.get(tutor_id, 0)
            new_assigned_student_count = sum(
                self.assign_vars[(s['studentId'], tutor_id)] for _, s in self.new_students.iterrows()
                )
            free_capacity[tutor_id] = tutor_max_capacity - existing_student_count - new_assigned_student_count

        logging.info(f'Optimizing based of Scenario: {scenario}')

        if scenario == 1:
            # Maximize preference but minimize total tutor count
            self.model.maximize(preference_term - tutor_used_term)
        elif scenario == 2:
            # Maximise preference and balance tutor workload
            workload_term = sum(free_capacity[t_id] * (1 - self.beta) for t_id in free_capacity)
            self.model.maximize(preference_term - workload_term)
            pass
        else:
            logging.error(f'No objective function for Scenario: {scenario}')
        return
    # def set_objective_function(self):
    #     '''
    #     Based on above constraint(s), maximimise 
    #     the total student-tutor assignment that matches tutor
    #     preffered centre(s) while at the same time minimize 
    #     the total number of tutor assigned to different students
    #     '''
    #     preference_matrix = {}
    #     for _,new_student in self.new_students.iterrows():
    #         for _,tutor in self.tutor_info.iterrows():
    #             if new_student['tuitionCentre'] == tutor['preferredCentre1']:
    #                 preference_matrix[new_student['studentId'],tutor['tutorId']] = 1
    #             elif new_student['tuitionCentre'] == tutor['preferredCentre2']:
    #                 preference_matrix[new_student['studentId'],tutor['tutorId']] = 0.5
    #             else:
    #                 preference_matrix[new_student['studentId'],tutor['tutorId']] = 0
        
    #     # Create a penalty term reduce free capacity for each tutor
    #     existing_counts = self.existing_students.groupby('tutorId').size().to_dict()
    #     free_capacity = {}
    #     for _, tutor in self.tutor_info.iterrows():
    #         tutor_id = tutor['tutorId']
    #         tutor_max_capacity = tutor['maxOverallCapacity']
    #         existing_student_count = existing_counts.get(tutor_id, 0)
    
    #         # Sum of all new students assigned to this tutor
    #         new_assigned_student_count = sum(
    #             self.assign_vars[(s['studentId'], tutor_id)] for _, s in self.new_students.iterrows()
    #             )
    #         # Free capacity = max - (existing + new assigned)
    #         free_capacity[tutor_id] = tutor_max_capacity - existing_student_count - new_assigned_student_count

    #     # Define the objective function
    #     ## Maximise the total student-tutor assignment that matches tutor preferred tuition centre
    #     ## But minimize total tutor resources used
    #     self.model.maximize(
    #          sum(self.assign_vars[new_student['studentId'], tutor['tutorId']] * self.beta * preference_matrix[new_student['studentId'], tutor['tutorId']]
    #             for _,new_student in self.new_students.iterrows()
    #             for _,tutor in self.tutor_info.iterrows())
    #         - sum(self.tutor_used[tutor_id] * (1 - self.beta) for tutor_id in self.tutor_used)
    #         - sum(free_capacity[tutor_id] * (1-self.beta) for tutor_id in free_capacity)
    #     )
    #     return
    
    def solve(self,log_output = True):
        '''
        Uses cplex to solve the constraint problem
        '''
        return self.model.solve(log_output=log_output)
    
    def print_solution(self,solution):
        '''
        Generate new student assignment to 
        tutors
        '''
        if solution:
            for (student_id,tutor_id),var in self.assign_vars.items():
                if var.solution_value > 0.5:
                    logging.info(f'Student {student_id} assigned to Tutor {tutor_id}')
        else:
            logging.warning('No solution')

    def export_solution(self,solution,file_name = 'assignment_results.csv'):
        '''
        Save new assignments each month in csv file
        '''
        if solution:
            records = []
            for (student_id,tutor_id),var in self.assign_vars.items():
                if var.solution_value > 0.5:
                    records.append({"StudentID": student_id,"TutorID":tutor_id})
            data = pd.DataFrame(records)
            data.to_csv(f'./results/scenario_{self.scenario}_{file_name}',index = False)
            logging.info(f"Solution exported to {file_name}")
        else:
            logging.warning("No solution to export")

        return

    def constraint_checker(self,solution,tol = 1e-5):
        '''
        Function to check if assignment(s) violate
        any constrainted mentioned
        '''
        if not solution:
            logging.warning("No solution")
            return
        
        violations = []

        # Each student assigned to exactly 1 tutor
        logging.info("Checking if all student assigned to exactly 1 tutor....")
        for _,student in self.new_students.iterrows():
            assigned = sum(
                self.assign_vars[(student['studentId'], tutor_id)].solution_value for tutor_id in self.tutor_used)
            if abs(assigned - 1) > tol:
                # Use a small tolerance (e.g., 1e-5) instead of 0 to account for 
                # floating-point rounding errors in the solver
                violations.append(f"Student {student['studentId']} assigned {assigned} tutors")
        
        # Check Tutor capacity didnt burst
        logging.info("Checking if any of the tutor's capacity has been burst...")
        existing_counts = self.existing_students.groupby('tutorId').size().to_dict()

        for _,tutor in self.tutor_info.iterrows():
            tutor_id = tutor['tutorId']
            max_capacity = tutor['maxOverallCapacity']
            new_student_count = sum(
                self.assign_vars[(student['studentId'], tutor_id)].solution_value
                for _, student in self.new_students.iterrows()
                )
            total_assigned = new_student_count + existing_counts.get(tutor_id,0)

            if total_assigned - max_capacity > tol:
                violations.append(f"Tutor {tutor_id} capacity exceeded: {total_assigned}/{max_capacity}")
        
        # Check if Extensive tutoringNeed student assigned to Extensive tutoringSkills tutor
        logging.info("Checking if Extensive tutoringNeed student assigned only to Extensive tutoringSkills tutors...")
        for _, student in self.new_students.iterrows():
            if student['tutoringNeed'] == 'Extensive':
                for _, tutor in self.tutor_info.iterrows():
                    if tutor['tutoringSkills'] != 'Extensive':
                        val = self.assign_vars[(student['studentId'], tutor['tutorId'])].solution_value
                        if val > tol:
                            violations.append(f"Student {student['studentId']} assigned to incompatible tutor {tutor['tutorId']}")
        
        if violations:
            logging.warning("Constraint violations found:")
            for v in violations:
                logging.warning(" - %s", v)
            return False
        else:
            logging.info("All constraints satisfied.")
            return True
        
    def tutor_summary(self,solution):
        '''
        Check to see if tutors are fully/partially utilized
        or idle
        '''
        if not solution:
            logging.warning("No solution.")
            return
        
        existing_counts = self.existing_students.groupby('tutorId').size().to_dict()
        summary = []

        for _,tutor in self.tutor_info.iterrows():
            tutor_id = tutor['tutorId']
            new_student_count = sum(
                self.assign_vars[(new_student['studentId'], tutor_id)].solution_value
                for _, new_student in self.new_students.iterrows()
                )
            total_count = new_student_count + existing_counts.get(tutor_id,0)
            free_capacity = tutor['maxOverallCapacity'] - total_count
            summary.append(
                {
                    "TutorID": tutor_id,
                    "NewAssigned": new_student_count,
                    "Existing": existing_counts.get(tutor_id, 0),
                    "TotalAssigned": total_count,
                    'MaxCapacity': tutor['maxOverallCapacity'],
                    "FreeCapacity": free_capacity
                }
                )
        tutor_summary = pd.DataFrame(summary)
        tutor_summary.to_csv(f"./results/scenario_{self.scenario}_tutor_summary.csv",index=False)
    
    def preference_satisfaction(self,solution):
        '''
        Function that generates dataframe to check
        how much of tutor preferred tuition centre(s)
        are actually choosen by the model
        '''
        if not solution:
            logging.warning("No solution.")
            return

        satisfied = 0
        total = 0

        logging.info("Calculate Total Satisfication of tutors...")
        
        for _,student in self.new_students.iterrows():
            for _,tutor in self.tutor_info.iterrows():
                value =  self.assign_vars[(student['studentId'], tutor['tutorId'])].solution_value
                if value > 0.5:
                    total += 1
                    if student['tuitionCentre'] in [tutor['preferredCentre1'],tutor['preferredCentre2']]:
                        satisfied += 1
        logging.info(f"Preference satisfaction: {satisfied}/{total} ({100*satisfied/total:.1f}%)")
        return satisfied / total if total > 0 else 0
    
    def preference_report(self,solution):
        '''
        Function that compares the new student's 
        tution centre against the tutor's preferred tuiton centre(s)
        '''
        if not solution:
            logging.warning("No solution.")
            return
        
        logging.info("Generate report of Student-Tutor Assignments...")

        records = []
        for _,student in self.new_students.iterrows():
            for _,tutor in self.tutor_info.iterrows():
                value = self.assign_vars[(student['studentId'], tutor['tutorId'])].solution_value
                if value > 0.5:
                    records.append({
                        "StudentID": student['studentId'],
                        "StudentCentre": student['tuitionCentre'],
                        "TutorID": tutor['tutorId'],
                        "TutorPref1": tutor['preferredCentre1'],
                        "TutorPref2": tutor['preferredCentre2'],
                        "MatchPref": student['tuitionCentre'] in [tutor['preferredCentre1'], tutor['preferredCentre2']]
                        }
                        )
        data = pd.DataFrame(records)
        data.to_csv(f"./results/scenario_{self.scenario}_preference_report.csv",index=False)
        return 

    def main_process(self):
        '''
        Encapsulate the entire model building &
        optimization process
        '''
        # Model building part
        self.create_variables()
        self.add_constraints()
        self.set_objective_function(scenario=self.scenario)
        solution = self.model.solve()
        # print solution
        self.print_solution(solution=solution)
        # check if any constraints got violated
        self.constraint_checker(solution=solution)
        # generate report on tutor capacity after optimization
        self.tutor_summary(solution=solution)
        # Find out total number of students for each tutor that are in 
        # tuition centres of tutor's preferred choice
        self.preference_satisfaction(solution=solution)
        # Generate data frame that compares student's tuition centre against
        # tutor preferred cchoices
        self.preference_report(solution=solution)
        # export solution
        self.export_solution(solution=solution)
