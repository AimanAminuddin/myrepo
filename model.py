import pandas as pd
from docplex.mp.model import Model

class TutorAssignmentModel:
    '''
    Wrapper class to optimize the assignment of 
    students to tutors based on both student preference(s)/
    tutor preference(s)
    '''
    def __init__(self,new_students,tutor_info,existing_students,beta = 0.9):
        '''
        Assign variable(s) to be class properties
        '''
        self.new_students = new_students
        self.tutor_info = tutor_info
        self.existing_students = existing_students
        self.beta = beta

        self.model = Model(name="tutor_student_assignment")
        # Assignment_variable_mappings
        self.assign_vars = {}
        self.tutor_used = {}

    # Create assigment variable(s)
    def create_variables(self):
        '''
        Create mappings for assignment of students and
        total of tutors used in each centre
        '''
        # Decision variable(s) that keep track of student-tutor assignment(s)
        self.assign_vars = {
            (new_student['studentId'], tutor['tutorId']): self.model.binary_var(name=f"x_{new_student['studentId']}_{tutor['tutorId']}")
            for _, new_student in self.new_students.iterrows()
            for _, tutor in self.tutor_info.iterrows()
            }

        # Decision variable that keep tracks if tutor is been utilised by
        # the tuition centre(s)
        self.tutor_used = {
            t['tutorId']: self.model.binary_var(name=f"tutor_used_{t['tutorId']}")
            for _, t in self.tutor_info.iterrows()
            }

    # Add constraints
    def add_constraints(self):
        '''
        Method that contains all the constraint(s) that 
        the solution(s) generated by the model require to adhere to
        '''
        # Each student assigned to exactly 1
        # tutor
        for _,new_student in self.new_students.iterrows():
            self.model.add_constraint(
                sum(self.assign_vars[new_student['studentId'], tutor['tutorId']]
                    for _, tutor in self.tutor_info.iterrows()) == 1,
                ctname=f"one_tutor_per_student_{new_student['studentId']}"
            )

        # Solution cannot exceed Tutor Capacity i.e. (new + existing students) <= MaxOverallCapacity
        ## Calculate total number of existing students by tutor
        existing_student_count = self.existing_students.groupby(['tutorId']).size().to_dict()

        for _,tutor in self.tutor_info.iterrows():
            # Iterate through each tutor and
            # ensure that each tutor max capacity
            # not violated
            tutor_id = tutor['tutorId']
            max_capacity = tutor['maxOverallCapacity']
            current_student_count = existing_student_count.get(tutor_id,0)

            self.model.add_constraint(
                sum(self.assign_vars[new_student['studentId'],tutor_id] for _,new_student in \
                    self.new_students.iterrows()) + current_student_count <= max_capacity,
                ctname=f"capacity_tutor_{tutor_id}"
            )

        # Skill compatability: Students with 'Extensive' tutoringNeed must
        # match with tutor(s) with 'Extensive' tutoringSkills
        for _,new_student in self.new_students.iterrows():
            for _,tutor in self.tutor_info.iterrows():
                if new_student['tutoringNeed'] == 'Extensive' and tutor['tutoringSkills'] != 'Extensive':
                    # force assignment to 0
                    # i.e. student now allowed to be taught
                    # specific tutor
                    self.model.add_constraint(
                        self.assign_vars[(new_student['studentId'],tutor['tutorId'])] == 0,
                        ctname=f"skill_block_{new_student['studentId']}_{tutor['tutorId']}"
                        )
        
        # tutor_used decision variable can only be set to 1
        # iff there exists tutor-student assignment for tutor
        for tutor_id in self.tutor_used:
            # If tutor already has existing students,tutor_used = 1
            if existing_student_count.get(tutor_id,0) > 0:
                # Set tutor_used to 1
                self.model.add_constraint(
                    self.tutor_used[tutor_id] == 1,
                    ctname=f"existing_tutor_used_{tutor_id}"
                    )
            else:
                # tutor_used = 1 if any new sutdent assigned
                for _,new_student in self.new_students.iterrows():
                    self.model.add_constraint(
                        self.assign_vars[(new_student['studentId'], tutor_id)] <= self.tutor_used[tutor_id],
                        ctname=f"link_assign_tutor_{new_student['studentId']}_{tutor_id}"
                        )

        return
    
    # Set the objective function
    def set_objective_function(self):
        '''
        Based on above constraint(s), maximimise 
        the total student-tutor assignment that matches tutor
        preffered centre(s) while at the same time minimize 
        the total number of tutor assigned to different students
        '''
        preference_matrix = {}
        for _,new_student in self.new_students.iterrows():
            for _,tutor in self.tutor_info.iterrows():
                if new_student['tuitionCentre'] == tutor['preferredCentre1']:
                    preference_matrix[new_student['studentId'],tutor['tutorId']] = 1
                elif new_student['tuitionCentre'] == tutor['preferredCentre2']:
                    preference_matrix[new_student['studentId'],tutor['tutorId']] = 0.5
                else:
                    preference_matrix[new_student['studentId'],tutor['tutorId']] = 0

        # Define the objective function
        ## Maximise the total student-tutor assignment that matches tutor preferred tuition centre
        ## But minimize total tutor resources used
        self.model.maximize(
             sum(self.assign_vars[new_student['studentId'], tutor['tutorId']] * self.beta * preference_matrix[new_student['studentId'], tutor['tutorId']]
                for _,new_student in self.new_students.iterrows()
                for _,tutor in self.tutor_info.iterrows())
            - sum(self.tutor_used[tutor_id] * (1 - self.beta) for tutor_id in self.tutor_used)
        )
        return
    
    def solve(self,log_output = True):
        '''
        Uses cplex to solve the constraint problem
        '''
        return self.model.solve(log_output=log_output)
    
    def print_solution(self,solution):
        '''
        Generate new student assignment to 
        tutors
        '''
        if solution:
            for (student_id,tutor_id),var in self.assign_vars.items():
                if var.solution_value > 0.5:
                    print(f'Student {student_id} assigned to Tutor {tutor_id}')
        else:
            print('No solution')

    def export_solution(self,solution,file_name = 'assignment_results.csv'):
        '''
        Save new assignments each month in csv file
        '''
        if solution:
            records = []
            for (student_id,tutor_id),var in self.assign_vars.items():
                if var.solution_value > 0.5:
                    records.append({"StudentID": student_id,"TutorID":tutor_id})
            data = pd.DataFrame(records)
            data.to_csv(file_name,index = False)
            print(f"Solution exported to {file_name}")
        else:
            print("No solution to export")

        return

    def constraint_checker(self):
        '''
        Function to check if assignment(s) violate
        any constrainted mentioned
        '''
        return

    def main_process(self):
        '''
        Encapsulate the entire model building &
        optimization process
        '''
        # Model building part
        self.create_variables()
        self.add_constraints()
        self.set_objective_function()
        solution = self.model.solve()

        # print solution
        self.print_solution(solution=solution)
        
        # export solution
        self.export_solution(solution=solution)

if __name__ == "__main__":
    DATA_PATH = "./data/small_data.xlsx"

    # Load specific sheets
    new_student_info = pd.read_excel(DATA_PATH, sheet_name="New Students")
    tutors = pd.read_excel(DATA_PATH, sheet_name="Tutor Information")
    existing_student_info = pd.read_excel(DATA_PATH, sheet_name="Existing Students")
    existing_student_info_filtered = existing_student_info[existing_student_info['active'] == True]
    print(new_student_info)
    print(tutors)

    optimizer = TutorAssignmentModel(
        new_students=new_student_info,tutor_info=tutors,
        existing_students=existing_student_info_filtered
        )

    optimizer.main_process()
